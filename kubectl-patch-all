#!/usr/bin/env ruby
# use kubectl to patch all matching items

def sh(command)
  puts command
  result = `#{command}`
  abort "#{command}\n#{result}" unless $?.success?
  result
end

def kubectl(command)
  sh "kubectl #{command}"
end

def extract_option(*formats, required:, has_value: true)
  formats.each do |option|
    ARGV.each_with_index do |arg, i|
      if arg == option # ["-p", "foo"]
        ARGV.delete_at i
        return has_value ? ARGV.delete_at(i) : true
      end
      if (value = arg[/^#{option}=(.*)/, 1]) # ["-p=foo"]
        ARGV.delete_at i
        return value
      end
    end
  end
  abort "No #{formats.join(" or ")} option given" if required
end

def discard_option(*formats, **kwargs)
  extract_option *formats, required: false, **kwargs
end

require 'json'
require 'shellwords'

abort "Need some arguments" if ARGV.size == 0
abort "First argument must be the resource (e.g. pods)" if (resource = ARGV.shift).start_with?("-")
patch = extract_option "-p", "--patch", required: true
type = extract_option "-t", "--type", required: true

# find items and confirm
list = JSON.parse(kubectl("get #{resource} #{ARGV.shelljoin} -o json")).fetch("items")
abort "No resources found" if list.size == 0
puts "Patch #{list.size} resources ? (y/n)"
abort unless $stdin.gets.strip == "y"

# remove options that patch does not support
discard_option "-l", "--selector"
discard_option "--field-selector"
discard_option "-n", "--namespace"
discard_option "-A", "--all-namespaces", has_value: false

# patch items (also supporting resource being "deployments,statefulsets")
list.each do |item|
  selector = "#{item.fetch("kind")} #{item.dig("metadata", "name")} -n #{item.dig("metadata", "namespace")}"
  puts kubectl("patch #{selector} --patch #{patch.shellescape} --type #{type.shellescape} #{ARGV.shelljoin}")
end
